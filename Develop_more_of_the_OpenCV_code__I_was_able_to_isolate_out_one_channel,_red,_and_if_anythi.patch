Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/ThresholdingTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/ThresholdingTest.java	(revision 2f7d27362aa1ca9bfc3b1b6421a3ddefc4fdde5a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/ThresholdingTest.java	(date 1634073667401)
@@ -5,6 +5,7 @@
 
 import org.firstinspires.ftc.robotcore.external.Telemetry;
 import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
+import org.opencv.core.Core;
 import org.opencv.core.Mat;
 import org.opencv.imgproc.Imgproc;
 import org.openftc.easyopencv.OpenCvCamera;
@@ -15,16 +16,19 @@
 @TeleOp
 public class ThresholdingTest extends LinearOpMode {
     OpenCvCamera webcam;
+    Threshold thresh;
 
     public void runOpMode(){
         int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
-        webcam = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class,  "Webcam 1"));
+        webcam = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class,  "Webcam 1"), cameraMonitorViewId);
 
+        thresh = new Threshold();
         webcam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()
         {
             @Override
             public void onOpened()
             {
+                webcam.setPipeline(thresh);
                 webcam.startStreaming(320, 240, OpenCvCameraRotation.UPRIGHT);
             }
 
@@ -46,11 +50,35 @@
 
     class Threshold extends OpenCvPipeline{
 
+        int stage = 0;
+        Mat ycrcb = new Mat();
+        Mat threshold = new Mat();
+
+        @Override
+        public void onViewportTapped() {
+            stage ++;
+
+            if(stage > 2){
+                stage = 0;
+            }
+        }
+
         @Override
         public Mat processFrame(Mat input){
-            Imgproc.threshold(input, input, 10, 100,1);
+            Imgproc.cvtColor(input, ycrcb, Imgproc.COLOR_RGB2YCrCb);
+            Core.extractChannel(ycrcb, ycrcb,0);
+            Imgproc.threshold(ycrcb, threshold, 255 * gamepad1.right_trigger, 100, Imgproc.THRESH_TOZERO);
 
-            return input;
+            switch (stage){
+                case 0:
+                    return ycrcb;
+                case 1:
+                    return threshold;
+                case 2:
+                    return input;
+                default:
+                    return  input;
+            }
         }
     }
 }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp/MecanumDrive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp/MecanumDrive.java	(revision 2f7d27362aa1ca9bfc3b1b6421a3ddefc4fdde5a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/TeleOp/MecanumDrive.java	(date 1634072667521)
@@ -4,6 +4,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
 import com.qualcomm.robotcore.hardware.DcMotor;
 import com.qualcomm.robotcore.hardware.DcMotorSimple;
+import com.qualcomm.robotcore.hardware.TouchSensor;
 
 @TeleOp
 public class MecanumDrive extends LinearOpMode {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/SwitchingViewportTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/SwitchingViewportTest.java	(date 1634070345604)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/SwitchingViewportTest.java	(date 1634070345604)
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2019 OpenFTC Team
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+package org.firstinspires.ftc.teamcode.tests;
+
+import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
+import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
+
+import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
+import org.opencv.core.Core;
+import org.opencv.core.Mat;
+import org.opencv.core.MatOfPoint;
+import org.opencv.core.Scalar;
+import org.opencv.imgproc.Imgproc;
+import org.openftc.easyopencv.OpenCvCamera;
+import org.openftc.easyopencv.OpenCvCameraFactory;
+import org.openftc.easyopencv.OpenCvCameraRotation;
+import org.openftc.easyopencv.OpenCvInternalCamera;
+import org.openftc.easyopencv.OpenCvPipeline;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * In this sample, we demonstrate how to use the {@link OpenCvPipeline#onViewportTapped()}
+ * callback to switch which stage of a pipeline is rendered to the viewport for debugging
+ * purposes. We also show how to get data from the pipeline to your OpMode.
+ */
+@TeleOp
+public class SwitchingViewportTest extends LinearOpMode
+{
+    OpenCvCamera webcam;
+    StageSwitchingPipeline stageSwitchingPipeline;
+
+    @Override
+    public void runOpMode()
+    {
+        /**
+         * NOTE: Many comments have been omitted from this sample for the
+         * sake of conciseness. If you're just starting out with EasyOpenCv,
+         * you should take a look at {@link InternalCamera1Example} or its
+         * webcam counterpart, {@link WebcamExample} first.
+         */
+
+        int cameraMonitorViewId = hardwareMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hardwareMap.appContext.getPackageName());
+        webcam = OpenCvCameraFactory.getInstance().createWebcam(hardwareMap.get(WebcamName.class, "Webcam 1"), cameraMonitorViewId);
+
+        stageSwitchingPipeline = new StageSwitchingPipeline();
+        webcam.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()
+        {
+            @Override
+            public void onOpened()
+            {
+                webcam.setPipeline(stageSwitchingPipeline);
+                webcam.startStreaming(640, 480, OpenCvCameraRotation.UPRIGHT);
+            }
+
+            @Override
+            public void onError(int errorCode)
+            {
+                /*
+                 * This will be called if the camera could not be opened
+                 */
+            }
+        });
+
+        waitForStart();
+
+        while (opModeIsActive())
+        {
+            telemetry.addData("Num contours found", stageSwitchingPipeline.getNumContoursFound());
+            telemetry.update();
+            sleep(100);
+        }
+    }
+
+    /*
+     * With this pipeline, we demonstrate how to change which stage of
+     * is rendered to the viewport when the viewport is tapped. This is
+     * particularly useful during pipeline development. We also show how
+     * to get data from the pipeline to your OpMode.
+     */
+    static class StageSwitchingPipeline extends OpenCvPipeline
+    {
+        Mat yCbCrChan2Mat = new Mat();
+        Mat thresholdMat = new Mat();
+        Mat contoursOnFrameMat = new Mat();
+        List<MatOfPoint> contoursList = new ArrayList<>();
+        int numContoursFound;
+
+        enum Stage
+        {
+            YCbCr_CHAN2,
+            THRESHOLD,
+            CONTOURS_OVERLAYED_ON_FRAME,
+            RAW_IMAGE,
+        }
+
+        private Stage stageToRenderToViewport = Stage.YCbCr_CHAN2;
+        private Stage[] stages = Stage.values();
+
+        @Override
+        public void onViewportTapped()
+        {
+            /*
+             * Note that this method is invoked from the UI thread
+             * so whatever we do here, we must do quickly.
+             */
+
+            int currentStageNum = stageToRenderToViewport.ordinal();
+
+            int nextStageNum = currentStageNum + 1;
+
+            if(nextStageNum >= stages.length)
+            {
+                nextStageNum = 0;
+            }
+
+            stageToRenderToViewport = stages[nextStageNum];
+        }
+
+        @Override
+        public Mat processFrame(Mat input)
+        {
+            contoursList.clear();
+
+            /*
+             * This pipeline finds the contours of yellow blobs such as the Gold Mineral
+             * from the Rover Ruckus game.
+             */
+            Imgproc.cvtColor(input, yCbCrChan2Mat, Imgproc.COLOR_RGB2YCrCb);
+            Core.extractChannel(yCbCrChan2Mat, yCbCrChan2Mat, 3);
+            Imgproc.threshold(yCbCrChan2Mat, thresholdMat, 102, 255, Imgproc.THRESH_BINARY_INV);
+            Imgproc.findContours(thresholdMat, contoursList, new Mat(), Imgproc.RETR_LIST, Imgproc.CHAIN_APPROX_SIMPLE);
+            numContoursFound = contoursList.size();
+            input.copyTo(contoursOnFrameMat);
+            Imgproc.drawContours(contoursOnFrameMat, contoursList, -1, new Scalar(0, 0, 255), 3, 8);
+
+            switch (stageToRenderToViewport)
+            {
+                case YCbCr_CHAN2:
+                {
+                    return yCbCrChan2Mat;
+                }
+
+                case THRESHOLD:
+                {
+                    return thresholdMat;
+                }
+
+                case CONTOURS_OVERLAYED_ON_FRAME:
+                {
+                    return contoursOnFrameMat;
+                }
+
+                case RAW_IMAGE:
+                {
+                    return input;
+                }
+
+                default:
+                {
+                    return input;
+                }
+            }
+        }
+
+        public int getNumContoursFound()
+        {
+            return numContoursFound;
+        }
+    }
+}
\ No newline at end of file
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/IntakeTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/IntakeTest.java	(revision 2f7d27362aa1ca9bfc3b1b6421a3ddefc4fdde5a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/tests/IntakeTest.java	(date 1634073790793)
@@ -3,6 +3,7 @@
 import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
 import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
 import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.hardware.DcMotorSimple;
 
 @TeleOp
 public class IntakeTest extends LinearOpMode {
@@ -10,6 +11,7 @@
         //You can create the motor and define it in the same line
         DcMotor intake = hardwareMap.get(DcMotor.class, "intake");
 
+        intake.setDirection(DcMotorSimple.Direction.REVERSE);
         telemetry.addLine("initialized");
         telemetry.update();
 
